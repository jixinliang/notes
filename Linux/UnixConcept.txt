内核(kernel): 可将操作系统定义为一种软件, 它控制计算机硬件资源, 提供程序运行环境. 这种软件称为内核, 它相对较小, 位于环境的核心
系统调用(system call): 内核的接口
公用函数库: 构建在系统调用接口之上
Shell: 特殊的应用程序, 为运行其他应用程序提供了一个接口
操作系统(OS): 内核 + system utility + 应用程序 + shell + 公用函数库

ISO: International Organization for Standardization
ISO C标准的意图是提供C程序的可移植性, 使其可适用于大量不同的操作系统, 而不只是UNIX系统, 定义了语法, 语义, 标准库
ANSI: American National Standards Institute 国标组织ISO中的美国成员
POSIX是一个由IEEE制定的标准族;制定标准操作系统接口, 后来扩展到shell和实用程序等
POSIX: Portable Operating System Interface

IEEE: Institute of Electrical and Electronics Engineers
SUS: Single UNIX Specification 单一UNIX规范
SUS是POSIX.1标准的一个超集, 它定义了一些附加接口扩展了POSIX.1规范提供的功能. POSIX.1相当于SUS中的基本规范部分
XSI: X/Open System Interface
POSIX.1中的X/Open系统接口选择表述了可选的接口, 也定义了遵循XSI的实现必须支持POSIX.1的那些可选部分, 那些必须支持, 只有遵循XSI的实现才能成为UNIX系统

通用任务(tesk): 正在被执行的程序
程序(app): 一个存储在磁盘上某个目录中的可执行文件
进程(process): 程序的执行实例
进程ID: UNIX系统确保每个进程都有一个唯一的数字标识符(总是非负整数)
线程: 一个进程只有一个控制线程--某一时刻执行的一组机器指令
线程ID: 与进程ID相同, 用来标识线程, 只在所属进程内起作用, 当在一进程中对某个特定线程进行处理时, 我们可以使用该线程ID引用它
守护进程: 在后台运行, 且不与终端连接的一种进程

时钟时间(wall clock time): 进程运行的总时间, 其值与系统中同时运行的进程数有关
时钟时间的单位是时钟滴答, 通常, 每秒滴答数在60~128之间
用户CPU时间: 执行用户指令所用的时间
系统CPU时间: 该进程执行内核程序所用的时间
CPU时间: 用户CPU时间 + 系统CPU时间

文件描述符(file descriptor, fd): 对内核而言, 所有打开的文件都通过文件描述符引用, 文件描述符是一个非负整数, 当打开或创建文件时, 内核向进程返回一个文件描述符 /dev/fd/

系统调用和库函数之间的差别:
- 从实现者的角度看, 系统调用和函数库之间有根本的区别, 但从用户的角度看, 其区别不重要, 其都是以C函数的形式出现, 都为应用程序提供服务. 如果希望可以替换掉函数库, 但是系统调用是不能被替换的. 
- 应用程序既可调用系统调用, 也可以调用库函数, 很多库函数则会调用系统调用
- 系统调用通常提供一个最小接口, 而库函数通常提供比较复杂的功能

对系统内核而言, 文本文件和二进制代码文件并无差别
I/O的效率: 4096字节buffer相对较优

原子操作(atomic operation): 由多个步骤组成的一个操作, 如果该操作原子地执行, 则要么执行完成所有步骤, 要么一步也不执行, 不可能只执行一部分

延迟写(delayed write): 向文件写数据时, 内核通常先将数据复制到缓冲区, 排入队列, 然后再写入磁盘
同步写(sync write): 只将所修改过的块缓冲区排入写队列, 然后就返回, 并不等待实际写磁盘操作结束
文件同步写(file sync write): 对指定文件描述符有作用, 且等待磁盘操作结束后才返回

二进制可执行文件: 为了执行程序, 内核必须理解其格式, 所有二进制可执行文件都遵循一种标准化的格式, 这种格式使内核能够确定程序文本和数据的加载位置

硬链接: 直接指向文件的索引节点（该链接和文件位于同一个文件系统; 超级用户才能创建硬链接, 且需底层文件系统支持）
符号链接: 对一个文件的间接指针

对一个目录有访问权限的任意用户都可以读该目录, 但是为了防止文件系统产生混乱, 只有内核才能写目录; 
一个目录的写权限位和执行权限位决定了在该目录中能否创建新的文件及删除以存在的文件, 并不表示写目录本身

每个进程都有一个当前工作目录, 此目录是搜索所有相对路径名的起点 /proc/self/cwd

全缓冲, 行缓冲, 无缓冲

对于ASCII字符集, 一个字符用一个字节表示; 对于unicode字符集, 一个字符可用多个字节表示

每个程序都接收到一张环境表, 与参数表一样, 环境表也是一个字符串指针数组, 其中每个指针都包含以NULL结束的c字符串的地址, 全局变量environ包含了该指针数组的地址

环境指针: 每个字符串的结尾处都显示地有一个NULL字节
环境表: 指针数组
环境字符串: 各指针指向的字符串

正文段(text segment): 由CPU执行的机器指令的部分, 通常,该段是可共享的, 所以即使频繁执行的程序在存储器中也只需要一个副本, 此外,该段常常是只读的以防止程序由于意外而修改其指令
初始化数据段(数据段 initialized data segment): 包含了程序中需要明确地赋值的变量
未初始化数据段(uninitialized data segment, bss: block started by symbol): 在程序开始执行之前, 内核将此字段中的数据初始化为0或空指针 
栈(stack): 自动变量及每次函数调用时所需保存的信息都存放在此字段中, 每次函数调用时, 其返回地址及调用者的环境信息(如某些机器寄存器的值)都存放在栈中, 最近被调用的函数在栈上为其自动和临时变量分配存储空间, 通过这种方式使用栈, 递归函数可以工作. 递归函数每次调用其自身时, 就用一个新的栈帧, 因此一次函数调用实例中的变量集不会影响应另一次函数调用实例中的变量. 
堆(heap): 通常在堆中进行动态存储分配, 历史原因, 堆位于未初始化数据段和栈之间

高地址: [命令行参数, 环境变量] -> 栈 -> 堆 -> 未初始化的数据(由exec初始化为0) -> 初始化的数据 -> 低地址: 正文(由exec从程序文件中读入)

为初始化数据段的内容并不存放在磁盘程序文件中, 因为内核在程序开始运行前将它们都设置为0, 需要存放在磁盘程序文件中的段只有正文段和初始化数据段

共享库: 使得可执行文件中不再需要包含公用的库函数, 而需要在所有进程都可引用的存储区中保存这种库函数的一个副本. 程序第一次执行或这第一次调用某个库函数时, 用动态链接方法将程序与共享库函数相链接. 这减少了每个可执行文件的长度, 但增加了运行时间开销. 这种时间开销发生在该程序第一次被执行时, 或每个共享库函数第一次被调用时, 其另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑(假设参数的数目和类型都没变) 可以减少编译出程序的体积

进程标识: 每个进程都有一个非负整型表示的唯一进程ID, 由于进程ID标识符总是唯一的, 长将其用作其他标识符的一部分以保证其唯一性

利用延迟复用算法, 保证被终止的候选进程ID的可用性

交换进程或调度进程(swapper): ID为0的进程; 系统中一些专用的进程, 具体实现不同, 该进程是内核的一部分, 它并不执行任何磁盘上的程序, 也称为系统进程

init进程: 进程ID为1, 在自举过程结束时由内核调用, 负责自举内核后启动一个UNIX系统, init通常读取与系统有关的初始化文件(/etc/rc*, /etc/init.d), 该进程决不会终止, 是一普通的用户进程(与交换进程不同, 它不是内核中的系统进程), 但它以超级用户特权执行

页守护进程: 进程ID为2, 此进程负责支持虚拟存储器系统的分页操作

子进程: 有fork函数创建的新进程. fork函数被调用一次, 但返回两次, 子进程的返回值是0, 而父进程返回值是新建子进程的进程ID
子进程和父进程继续执行fork调用之后的指令. 子进程是父进程的副本, 其获得父进程数据空间,堆和栈的副本, 但并不共享存储空间部分, 共享正文段

由于在fork之后经常跟随exec,所以很多实现并不执行一个父进程数据段,栈和堆的完全副本. 作为替代, 使用写时复制(Copy-On-Write)技术. 这些区域有父子进程共享, 且内核将他们的访问权限给变为只读. 父子进程中的任一个试图修改这些区域, 则内核只为修改区域的那块内存制作一个副本, 通常是虚拟存储系统中的一"页"

init进程收养: 对于父进程已经终止的所有进程, 它们的父进程都被改变为init进程. 大致流程, 在一个进程终止时, 内核逐个检查所有活动进程, 以判断它是否是要终止进程的子进程, 如果要, 则该进程的父进程ID就被更改为1（init进程的ID, 这种处理办法保证了每个进程有一个父进程)

僵尸进程(zombe): 一个已经终止, 但是其父进程尚未对其进行善后处理(获取终止子进程的有关信息, 释放它占用的资源)的进程

竞争条件: 当多个进程都企图对共享数据进行某种处理, 而最后的结果又取决于进程运行的顺序

#! pathname 在叹号和pathname之间的空格是可选的
解释器文件: 文本文件, 以#!pathname开头
解释器: 由解释器文件第一行中的pathname指定
pathname通常是绝对路径, 对它不进行什么特殊处理(不使用PATH进行路径搜索), 对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的, 内核使调用exec函数的进程实际执行的并不是该解释器文件, 而是在该文件第一行中的pathname所制定的文件

system: fork -> exec -> waitpid

nice: 进程可以调整nice值选择以更低优先级运行(通过调整nice值降低它对CPU的占用), 只有root进程允许提高调度权限
nice值越小, 优先级越高(越友好, 调度优先级就越低)

每个进程都有一个父进程(初始的内核级进程通常是自己的父进程), 当子进程终止时, 父进程得到通知并能获得子进程的退出状态

init(进程ID1) --fork-> init --exec-> getty(打开终端设备, 文件描述符0, 1, 2)
init(进程ID1) --fork-> init --exec-> getty --exec-> login
进程ID不会因为执行exec而该改变, 除了最初的init进程, 所有进程的父进程ID均为1

用户登陆流程:
login能处理多项工作, 得到用户名, 
调用getpwnam获取相应用户登陆项, 
调用getpass显示提示“Password: ”, 读入用户的密码(密文), 
调用crypt将用户输入的密码, 与该用户在shadow文件中登陆项的pw——passwd字段相比较. 
如果用户几次输入错误, 则login以参数1调用exit表示登陆失败, 父进程(init)获得子进程终止状况后, 
将再次调用fork, 然后又执行getty, 重复验证过程

PAM: pluggable authentication modules

登陆后流程:
调用chdir将当前工作目录更改为该用户的起始目录, 
调用chown更改终端的所有权, 使登陆用户成为它的所有者, 
调用setgid及initgroups设置进程的组ID, 
用login得到的所有信息初始化环境: HOME, SHELL, USER, LOGNAME, PATH
login进程调用setuid更改登陆用户的ID并调用该用户登陆shell

登陆用户的shell开始运行, 其父进程ID是init进程为1, 所以当次登陆终止时, init会得到通知(接收SIGCHLD信号), 
再次重复以上过程, 登陆shell的文件描述符0, 1, 2设置为终端设备
登陆shell读取其启动文件(.profile, .bashrc)这些文件通常更改某些环境变量, 
并增加很多环境变量

init(进程ID1) --getty, login-> 登陆shell --fd 0, 1, 2-> 终端设备驱动 --硬连接-> 终端用户

伪终端(pseudo terminal)软件驱动程序: 使同一个软件既能处理终端登陆, 又能处理网络登陆, 它仿真串行终端的运行行为, 将终端映射为网络操作

init(进程ID1) --系统出现多个用户时, bash中的fork/exec, 执行shell脚本/etc/rc-> 从ssh通过tcp连接 inetd -- fork, 从ssh进来连接请求时 -> inetd --exec-> sshd

init(进程ID1) --通过inetd, ssh, login-> 登陆shell --fd 1, 2, 3-> 伪终端设备驱动 --通过sshd服务器和ssh客户端的网络连接-> 终端用户

进程组: 一个或多个进程的集合, 通常, 它们是在同一作业中结合起来的, 同一进程组中的各进程, 接收来自同一终端的这种信号. 每个进程组有一个唯一的进程组ID, 且是正整数

组长进程: 每个进程都有一个组长进程, 其进程组ID等于其进程ID; 可以创建一个进程组, 创建该组中的进程, 然后终止, 只要某个进程组中仍有进程存在, 则该进程组就存在, 与其组长进程是否终止无关. 进程组中的最后一个进程可以终止, 也可以转移到另一个进程组
进程组的生命周期: 从进程组创建开始到最后一个进程离开为止的之间区间

一个进程只能为它或它的子进程设置进程组ID, 在它的子进程调用了exec后, 它就不再更改该子进程的进程组ID

会话(session): 一个或多个进程组的集合
通常由shell的管道将几个进程编成一组 例: cat exam.txt|wc -l|sort|uniq -c

如果该调用进程已经时一个进程组的组正, 为了不出错, 通常先调用fork, 然后使其父进程终止, 而子进程继续, 因为子进程继承了父进程的进程组ID, 而其进程ID则是新分配的, 两者不可能相等, 这就保证了子进程不是一个进程组的组长
会话ID: 会话首进程的进程组ID, 会话首进程总是一个进程组的组长进程

控制进程: 建立与控制终端连接的会话首进程

一个会话可以有一个控制终端(终端设备或伪终端设备)
一个会话中的几个进程组被分成一个前台进程组, 及一个或多个后台进程组
无论何时输入终端的中断键(Ctrl+C), 都会将中断信号发送到前台进程组的所有进程

一个作业: 是几个进程的集合

tail -f args.c &
fg %1

stty -a

ps的父进程时shell
ps -o pid, ppid, pgid, sid, comm

进程并没有终端进程控制组, 进程属于一个进程组, 而进程组属于一个会话, 会话可能有也可能没有控制终端, 如果它的确有一个控制终端, 则此终端知道其前台进程的进程组ID; 前台进程组ID是终端的一个属性, 而不是进程的属性

$ ps -o pid, ppid, pgid, sid, tpgid, comm|cat|cat
    PID    PPID    PGID     SID   TPGID COMMAND
   7155    7105    7155    7155    8254 zsh
   8254    7155    8254    7155    8254 ps
   8255    7155    8254    7155    8254 cat
   8256    7155    8254    7155    8254 cat

shell将前台作业ps放进了它自己的进程组, ps命令是进程组组长进程, 也是该进程组的唯一进程.次进程组具有控制终端, 所以它是前台进程组, 我们的登陆shell在执行ps命令时是后台进程组, 这两个进程组都是同一会话的成员

孤儿进程组: 
- 该组中每个成员的父进程要么是改组的一个成员, 要么不是改组所属会话的成员;
- 一个进程组不是孤儿进程组的条件是, 该组中有一个进程, 其父进程在属于同一个会话的另一个组中.如果进程组不是孤儿进程组, 那么在属于同一会话的另一个组中的父进程就有机会重新启动该进程组停止的进程, 在这里, 进程组中每个进程的父进程都属于另一个会话, 因此次进程是孤儿进程组

父进程终止时, 子进程变成后台进程组, 因为父进程是由shell作为前台作业执行的

产生core文件是大多数UNIX系统的实现功能
linux下 /proc/sys/kernel/core_pattern

不产生core文件: 
进程是设置用户的ID, 但当前用户不是程序文件的所有者; 
进程是设置组的ID, 但当前用户不是程序文件的组所有者; 
用户没有当前工作目录的写权限; 
文件已经存在, 但用户用户对文件没有写权限; 
文件太大; 

SIGABRT: abort 进程异常终止
SIGALRM: alarm 定时器超时
SIGBUS: 硬件故障, 如内存故障
SIGCHLD/SIGCLD: 一个进程终止或停止时, 该信号被发送给其父进程, 系统默认忽略次信号.如想捕捉次信号, 使用wait函数获取子进程的ID及终止状态
SIGCONT: 作业控制信号, 发送给状态已经停止, 但需要继续运行的进程.接收到该信号, 系统默认使该进程继续运行, 否则默认忽略此信号
SIGEMT: emulator trap 提示一个实现定义的硬件故障
SIGFPE: 算术运算异常, 如除以0, 浮点益处
SIGHUP: 终端控制进程(会话首进程)检测终端接口是否有断开的非正常信号.接收到次信号的会话首进程可能在后台;如果会话首进程终止, 也产生此信号, 此次信号发送给前台进程组的每一个进程;通常次信号通知守护进程再次读取它们的配置文件
SIGILL: 进程执行了非法硬件指令
SIGINT: 中断 Ctrl+C
SIGIO: 提示一个异步I/O事件
SIGIOT: 提示一个实现定义的硬件故障
SIGPIPE: 提示写入一个已经终止的管道
SIGPWR: 依赖于不间断电源的系统的系统, 电源失效, UPS电源其作用时, 触发该信号, 如果UPS电源也不能支持工作, 发送该信号给init进程, 由init进程处理停机操作
SIGQUIT: Ctrl+\ 中断启动程序产生此信号
SIGSEGV: segmentation violation 提示进程引用了无效的内存
SIGSTKFLT: 数学协处理器的栈故障
SIGKILL: 不能被捕捉或忽略的信号, 可杀死任意一个进程
SIGSTOP: 同样不能被捕捉或忽略的信号, 用于停止一个进程
SIGSYS: 提示一个无效的系统调用, 进程执行了一条机器指令, 内核认为这是一条系统调用, 但该指令指示系统调用类型的参数却无效, 如执行的二进制可执行代码, 而操作系统不支持该系统调用的较早版本
SIGTERM: 由kill命令发送的系统默认终止信号, 由于信号是由应用程序捕获的, 使用该信号可以让程序有机会退出前做好清理工作, 而优雅的终止
SIGTRAP: 提示一个实现定义的硬件故障
SIGTSTP: 交互停止信号Ctrl+Z, 在终端上挂起
SIGTTIN: 后台进程试图读其控制终端时, 触发次信号. 意外情况不产生此信号:读进程忽略或阻塞此信号, 读进程所属的进程组时孤儿进程组, 则此操作返回出错, errno设为EIO
SIGTTOU: 后台进程组进程试图写其控制终端时, 一个进程可以选择允许后台进程写控制终端
SIGURG: 已经发生一个紧急状况, 
SIGUSR1: 用户定义的信号, 可用于应用程序
SIGUSR2: 另一个用户定义的信号
SIGVTALRM: setitimer函数的设置的虚拟间隔时间超时时, 触发
SIGWINCH: 内核维持与每个终端或伪终端相关联窗口的大小
SIGXCPU: 进程超过其软CPU时间限制
SIGXFSZ: 进程超过其软文件长度限制

程序启动: 等执行一个程序时, 所有信号的状态都是系统默认或忽略.通常设置为它们的默认动作, 除非调用exec的进程忽略该信号, ecec函数将原先设置为要捕捉的信号都更改为默认动作, 其他信号的状态则不变(一个进程原先要捕捉的信号, 当其执行一个新程序后, 就不能在捕捉了, 信号捕捉函数的地址很可能在所执行的新程序文件中已无意义)

不改变信号的处理方式就不能确定信号的当前处理方式

进程创建: 当一个进程调用fork时, 其子进程继承父进程的信号处理方式, 因为子进程在开始时复制了父进程内存镜像, 所以信号捕捉函数的地址在子进程中时有意义的

低速系统调用: 可能会使进程永远阻塞的一类系统调用
- 某些类型文件(如读管道, 终端设备, 网络设备)的数据不存在, 读操作可能会永远阻塞
- 这些数据不能被相同的类型文件立即接受
- 某种条件发生之前打开某些类型文件, 如打开一个终端设备, 需要先等待与之连接的调制解调器答应
- pause函数, wait函数
- 某些ioctl操作
- 某些进程通信函数

自启动功能: 由时用户并不知道使用的输入, 输出设备是否是低速设备.如果我们编写的程序可以用交互方式运行, 则它可能读, 写低速终端设备, 如果在程序中捕捉信号, 而系统不提供重启功能, 则对每次读, 写系统调用就进程是否出错返回的测试, 如果是被中断的, 则再次调用读, 写系统调用

异步信号安全: 在信号程序中保证调用安全的函数, 这些函数是可重入的, 在信号处理操作期间, 它会阻塞任何会引起不一致的信号发送

不可重入函数特点:
- 它们使用静态数据结构
- 它们调用malloc或free
- 它们是标准I/O函数, 此库的很多实现都以不可重入方式使用全局数据结构

信号使用场景:
当造成信号的事件发生时, 为进程产生一个信号(向一个进程发送一个信号); 
事件可以是硬件异常(处以0), 软件条件(alarm定时器超时);
终端产生的信号或调用kill函数.
当一个信号产生时, 内核通常在进程表现中以某种形式设置一个标志.

信号是pending的: 向进程传递一个信号, 信号在产生和传递之间的时间间隔内的状态

阻塞信号传递: 为进程产生了一个阻塞的信号, 而对该信号的动作是系统默认动作或捕捉该信号, 则该进程将此信号保持为pending状态, 直到该进程对此信号解除了阻塞, 或对此信号的动作更改为忽略.内核在传递一个原来被阻塞的信号给进程时, 才决定对它的处理方式.所以进程在信号传递给它之前仍可改变对该信号的动作

信号排队: 在进程解除对某个信号的阻塞之前, 发送了该信号多次 

系统进程集: 内核进程 + init(pid为1)

信号集数据类型: 用来表示多个信号

C编译程序将不赋初始值的外部变量和静态变量都初始化为0

控制线程: 在单进程环境中执行多个任务, 一个进程中的所有线程都可以访问该进程的组成部件, 如文件描述符和内存

不管在什么情况下, 只要单个资源需要在多个用户建共享, 就必须处理一致性问题

一个线程在某一时可只能作一件事, 有个多个控制线程后, 在程序设计时就可以把线程设计成在某一时能够做不止一件事, 每个线程
处理各自独立的任务

多线程的好处:
- 为每种事件类型分配单独的处理线程, 可以简化处理异步事件的代码, 那个线程在进程事件处理时可以采用同步编成模式, 该模式比异步编成模式简单的多
- 多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享, 而多个线程自动地可以访问相同的内存地址空间和文件描述符
- 有些问题可以分解从而提高整个代码的吞吐量, 在只有一个控制线程的情况下, 一个单线程进程要完成多个任务, 只需要把这些任务串行化.但是有多个控制线程时, 相互独立的任务的处理就可以交叉进行, 此时只需要为每个任务分配一个单独的线程, 当然只有在两个任务的处理过程互不依赖的情况下, 两个任务可以交叉执行
- 交互的程序同样可以通过使用多线程来改善响应时间, 多线程可以把程序中处理用户输入输出的部分与其他部分分开

一个进程的所有信息对该进程的所有线程都是共享的, 包括可以执行的代码, 程序的全局内存, 堆内存, 栈以及文件描述符
 
和进程ID一样, 每个线程也有一个线程ID, 进程ID在整个系统中是唯一的, 但线程ID不同, 线程ID只有在它所属的进程上下文中才有意义

线程创建时并不能保证那个线程会现运行: 是新创建的线程, 还是调用线程.新创建的线程可以访问进程的内存地址, 且继承调用线程的浮点环境和信号屏蔽字, 但该线程的挂起信号集会被清除

线程同步: 当多个控制线程共享相同的内存时, 需要确保每个线程看到一致的数据视图, 
不用同步情况:
每个线程使用的变量都是独立的, 其他线程不会读取和修改; 变量只读
需要同步情况:
线程俄可以改变的变量, 其他线程也可以读取或修改, 则需要线程进程同步, 确保他们在访问变量的内存内容时不会访问无效的值

一个线程修改变量时, 其他线程读取这个变量时可能看到一个不一致的值:
变量修改时间多于一个存储器访问周期的处理器结构中;
存储器读与写这两个周期交叉

线程A读取变量然后给这个变量赋予一个新的数值, 但写操作需要两个存储周期.当线程B在这两个存储器写周期中间读取这个变量时, 就会得到不一致的值

为了解决这个问题, 线程不得不使用锁, 即同一时间只允许一个线程访问该变量

两个或多个线程是试图在同同一时间修改同一变量时, 也需要进行同步:
1.从内存单元读入寄存器
2.在寄存器中对变量做增量操作
3.把新的值写会内存单元

如果修改操作是原子操作, 就不存在竞争
如果增加1只需要一个存储器周期, 就不存在竞争
如果数据总是以顺序一致出现, 就不需要额外的同步

多个线程观察不到数据的不一致时, 该操作是顺序一致的

互斥锁: 本质是一把锁, 在访问共享资源前对其进行加锁, 在访问完成后释放锁.对资源进行加锁后, 其他试图访问该资源的线程都会被阻塞直到当前线程释放了该锁, 如果释放时由一个以上的线程在阻塞中, 那么所有被阻塞的线程都会变成可运行状态, 第一个变成可运行的线程就会又对该资源加锁, 其他线程看到该资源依然是上锁的, 只能回去再次等待它重新变成可用, 每次只有一个线程可以向当前执行

只有将所有程序都设计成遵守相同数据访问规则时, 互斥机制才能正常工作.操作系统并不会为我们做数据访问的串行化

保护某个数据结构的互斥锁: 当一个以上的线程需要访问动态分配的对象时, 我们可以在对象中嵌入引用计数, 确保在所有使用该对象的线程完成数据访问之前, 该对象内存空间不会被释放

如果线程试图对同一个资源加锁两次, 那么其自身也会被陷入死锁状态, 但是使用互斥锁时, 还有其他不太明显的方式也能产生死锁
程序使用一个以上的互斥锁时;
如果允许一个线程一直占用第一个互斥锁, 且试图锁住第二个互斥锁时处于阻塞状态, 但拥有第二个互斥锁的线程也在试图锁住第一个互斥锁, 因为两个线程都在相互请求另一个线程拥有的资源, 所以两个线程都无法前进运行, 则产生死锁

可能发生的死锁只会发生在一个线程试图锁住另一个线程以相反的顺序锁住的资源

应用程序的机构使得对互斥锁进行排序很困难, 如果涉及了太多的锁和数据结构, 可用的函数并不能把它转换成简单的层次, 可以现释放占有的锁, 做好清理工作, 然后过一段时间在重新试

锁线程的软件设计涉及两种折中: 
如果锁粒度太粗, 就会出现很多线程阻塞等待相同的锁, 这可能应不能改善并发性;
如果锁粒度太细, 过多的锁开销会使系统的性能受到影响, 而且代码变得复杂;
所以需要在满足锁需求的情况下, 在代码复杂性和性能之间找到正确的平衡

读写锁与互斥锁类似, 但读写锁允许更高的并发性.
互斥锁要么时锁住状态, 要么时不加锁状态
读写锁由3种状态:
读模式下加锁状态;
写模式下加锁状态;
不加锁状态

读写锁是写加锁状态时, 在这个锁被解锁之前, 所有试图对该锁加锁的线程都会被阻塞;
读写锁是读加锁状态时, 所有试图读模式对其进行加锁时线程都可以得到访问权, 但任何希望以写模式对此锁进行加锁的线程都会被阻塞, 直到所有的线程释放他们的读锁为止

读写锁处于读模式锁住的状态, 而此时有一个线程试图以写模式获取该锁时, 读写锁通常会阻塞随后的读模式请求.这样可以避免读模式锁长期占用, 而等待的写模式锁的请求一直得不到满足

读写锁市场适合于数据结构读的次数远大于写的情况:
当读写锁在写模式下时, 它所保护的数据结构就可以被安全地修改, 因为一次只有一个线程在写模式下拥有这个锁;
当读写锁在读模式下时, 只要线程先获取了读模式下的读写锁, 该锁所保护的数据结构就可以被多个获得读模式锁的线程读取

读写锁也叫共享互斥锁, 当读写锁时读模式锁住时, 就可以说成是以共享模式锁住的, 当它是以写模式锁住时, 就可以说成是互斥模式锁住的

线程安全: 如果一个函数在相同的时间点可以被多个线程安全地调用

异步信号安全: 函数对异步信号处理程序的重入是安全的

锁是递归的: 当一个进程占有了这把锁的时候, 还是可以再次获取该锁, 而且不会导致死锁

线程特定/私有数据: 存储和查询某个特定线程相关数据的一种机制. 希望每个线程都可以访问它自己单独的数据副本, 而不需要担心与其他线程的同步访问问题

当线程调用fork时, 就为子进程创建了整个进程地址空间的副本, 子进程与父进程时完全不同的进程, 只要二者都没有对内存内容做出任何改动, 父进程和子进程之间还可以共享内存页的副本

子进程通过继承整个地址空间的副本, 还从父进程那儿继承了每个互斥锁, 读写锁和条件变量的状态.如果父进程包含一个以上的线程, 子进程在fork返回以后, 如果不是立即调用exec的话, 就需要清理锁定状态

在子进程内部, 只存在一个线程, 它是由父进程中调用fork的线程副本构成的.如果父进程中的线程占有锁, 子进程将同样占有这些锁, 但是子进程并不包含占有锁的线程的副本, 所以子进程没有办法知道它占有了那些锁, 需要释放那些锁
如果子进程从fork返回以后就立即调用其中一个exec函数, 就可以避免这样的问题, 此时, 旧的地址空间被丢弃, 因此锁的状态无关紧要, 但如果该子进程需要继续处理任务, 这样就行不通, 需要其他策略

守护进程: 生存期长的一种进程.通常在系统引导装入时启动, 仅在系统关闭时才终止.因为它们没有终端控制, 所有说他们是在后台运行的, UNIX系统由很多守护进程, 它们执行日常事务活动

进程依赖于操作系统的实现, 父进程ID为0的各个进程通常是内核进程, 它们作为系统引导装入过程的一部分而启动.
内核进程是特殊的, 通常存在于系统的整个生命周期中.它们以超级用户权限运行着, 无控制终端, 无命令行

init是个例外, 它是一个由内核在引导装入时启动的, 用户层次的命令

内存换页守护进程: kswapd 支持虚拟内存子系统在经过一段时间后将脏页面慢慢地写回磁盘来回收这些页面

flush守护进程: 在可用内存达到设置的最小阀值时将脏页面冲洗至磁盘, 也定期地将脏业面冲洗回磁盘来减少在系统出现故障时发生数据丢失.多个冲洗守护进程可以同时存在, 每个写回的设备都有一个冲洗守护进程, 

init: 进程号为1, 系统守护进程, 除了其他工作外, 主要负责启动各运行层次特定的系统服务, 这些服务通常是在他们自己拥有的守护进程的帮助下实现的

大多数用户层守护进程都是进程组的组长进程以及会话的首进程, 而且是这些进程组和会话中的唯一进程, 用户层守护进程的父进程是init进程

使调用进程: 成为会话的首进程;成为一个新进程组的组长进程;没有控制终端

单例守护进程: 为了正常运作, 某些守护进程会实现为, 在任一时刻只运行该守护进程的一个副本.文件和记录锁机制为中方法提供了基础, 如果每一个守护进程创建一个有固定名字的文件, 并在该文件的整体加了一把锁, 只允许创建一把这样的锁, 在此之后创建锁的尝试都会失败, 这向后续守护进程副本指明已有一个副本正在运行
文件和记录锁提供了一种方便的互斥机制.如果守护进程在一个文件的整体上得到了一把写锁, 那么在该守护进程终止时, 这把锁将被删除, 这就简化了复原所需的处理, 去除了对以前的守护进程需要进行清理的有关操作

守护进程的惯例: 
- 使用锁文件, 通常放在/var/run目录中, 可能需要超级用户权限才能再此目录创建文件, 锁文件的名字通常是named.pid, named是该守护进程或服务的名字
- 若支持配置选项, 配置文件同通常放在/etc目录中, 文件名通常是name.conf, name是该守护进程或服务的名字
- 可用命令行启动, 通常他们是系统初始化脚本之一(/etc/rc*或/etc/init.d/*)启动的.
- 若守护进程有配置文件, 该守护进程在启动时会读该文件, 但此后一般不会在查看它, 如果修改了该进程的配置文件, 需要停止后, 在启动, 使配置文件生效, 为了避免此种麻烦, 某些守护进程将捕捉SIGHUP信号, 当他们接收到该信号时, 将重新读配置文件, 因为他们并不与终端相结合, 他们或者是无控制终端的会话首进程, 或是孤儿进程组的成员, 所以守护进程没有理由期望接收到SIGHUP, 因此, 守护进程可以安全地重复使用SIGHUP

保持文件描述符一直打开状态会导致安全问题, 被执行的程序肯可能有一些恶意行为, 更改服务器配置文件或欺骗客户端程序使其认为正在与服务器端通信, 从而获取未授权的信息, 因此应该为所有被执行程序不需要的文件描述符设置执行时关闭标志


系统调用分为两类: "低速"系统调用和其他
低速系统调用是可能会使进程永远阻塞的一类系统调用:
- 某些文件类型(读管道, 终端设备和网络设备)的数据不存在, 该读操作可能会使调用着永远阻塞
- 数据不能被相同的文件类型立即接受(管道中无空间, 网络流控制), 该写操作可能会使调用着永远阻塞
- 某种条件发生之前打开某些文件类型可能会发生阻塞, 如打开一个终端设备, 需要先等待与之连接的调制解调器答应, 若只写模式打开FIFO, 那么在没有其他进程已用读模式打开该FIFO时也要等待
- 对已经加上强制性记录锁的文件进行读写
- 某些ioctl操作
- 某些进程间通信函数

虽然读写磁盘文件也会暂时阻塞调用着, 但并不能将磁盘I/O有关的系统调用视为"低速"

记录锁(record locking): 当一个程序正在读或修改文件的某个部分时, 使用记录锁可以阻止其他进程修改同一文件区, 对UNIX系统而言, "记录"一词是一种误用, 因为UNIX系统内核没有使用文件记录这种概念.一个更合适的术语可能是"字节范围锁", 因为它锁定的只是文件中的一个区域, 也可能是整个文件

共享读锁和独占性锁: 任意多个进程在一个给定的字节上可以有一把共享的读锁, 但在一个给定的字节上只能有一个进程有一把独占写锁.如果一个给定字节上已经有一把或多把读锁, 则不能在该字节上再加写锁;如果在一个字节上已经有一把独占性写锁, 则不能再对它加任何读锁
--------------------------
		  请求
--------------------------
	  		 | 读锁 | 写锁
--------------------------
     无锁  	 | 允许 | 允许
--------------------------
一把或多把读锁 | 允许 | 拒绝 
--------------------------
  一把写锁 	 | 拒绝 | 拒绝
--------------------------

兼容性规则适用于不同进程提出的锁请求, 并不适用于单个进程提出的多个锁请求.如果一个进程对一个文件区域已经有了一把锁, 后来该进程又企图在同一文件区域再增加一把锁, 那么新锁将替换已有锁

如果一个进程在某文件的10~16字节区间有一把写锁, 然后又试图在10~16字节区间加一把读锁, 那么该请求成功执行, 原来的写锁会被替换为读锁

加读锁时, 该描述符必须是读打开, 加写锁时, 该描述符必须是写打开

在设置或释放文件上的一把锁时, 系统按要求组合或分裂相邻区, 若第100~199字节时加锁区, 需要解锁第150字节, 则内核将维持两把锁, 一把用于第100~149字节, 另一把用于第151~199字节; 如果我们又对150字节加锁, 那么系统将会再把3个相邻的加锁区和并成一个区域

死锁: 如果两个进程相互等待对方持有且不释放锁定的资源时, 则这两个进程就处于死锁状态;如果一个进程已经控制了文件中的一个加锁区域, 然后它又试图对另一个进程控制的区域加锁, 那么它就会休眠, 可能发生死锁

检测到死锁时, 内核必须选择一个进程接受出错返回, 有时是父进程, 有时是子进程

锁与进程和文件二者的关联: 
当一个进程终止时, 它所建立的锁全部释放;
无论一个描述符何时关闭, 该进程通过这个描述符引用的文件上的任何一把锁都会释放(这些锁时该进程设置的);
由fork产生的子进程不继承父进程所设置的锁;
在执行exec后, 新程序可以继承原执行程序的锁, 如果一个文件表述符设置设置了执行时关闭标志, 那么作为exec的一部分关闭该文件描述符, 将释放相应文件的所有锁

合作进程: 所有函数都以一致的方法处理记录锁

当两个人同时编辑用一个文件时将会怎样? 一般UNIX系统文本编译器并不使用记录锁, 因此该文件的最后结果取决于该文件的最后一个进程

I/O多路复用 multiplexing: 先构造一直那个我们感兴趣的描述符的列表, 然后调用一个函数, 直到这些描述符中的一个已经准备好进行I/O时, 该函数才返回, 在从这些函数返回时, 进程会告知那些描述符已经准备好可以进行了

并不能把非异步I/O函数称作"同步"的, 因为尽管他们相对与程序来说是同步的, 但相对与I/O来说并非如此

进程间通信: interProcess Communication, IPC

管道的局限性: 他们是半双工的(数据只能在一个方向上流动), 现在, 某些系统提供全双工管道, 但是为了最佳的可移植性, 不能预先假定系统支持全双工管道;管道只能在具有公共元进程的两个进程之间使用, 通常, 一个管道由一个进程创建, 在进程调用fork之后, 这个管道就能在父进程和子进程之间使用了

尽管有局限性, 半双工管道仍是最常使用的IPC形式, 每当在管道中输入一个命令序列, 让shell执行时, shell都会为每一个命令单独创建一个进程, 然后用管道将前一个命令进程的标准输出与后一个命令的标准输入相连接

协程: UNIX系统过滤程序从标准输入读取数据, 向标准输出写数据, 几个过滤程序通常在shell管道中现行连接, 当一个过滤程序既产生某个过滤程序的输入, 有读取该过滤程序的输出时, 就变成了协同程序

FIFO: 命名管道, 未命名的管道只能在两个相关的进程之间使用, 且这两个相关的进程还要有一个共同的创建了他们的元进程, 但是通过FIFO, 不相关的进程也能交换数据

FIFO的用途: 
shell命令使用FIFO将数据从一条管道传送到另一条时, 无需创建中间临时文件; 
客户端进程-服务端进程应用程序中, FIFO用作聚集点, 在客户端进程和服务端进程二者之间安传递数据

FIFO可用于复制一系列shell命令中的输出流, 这就防止了将数据写向中间磁盘文件, 类似于使用管道来避免中间磁盘文件, 但是不同的是, 管道只能用于两个进程之间的线性连接, 而FIFO是有名字的, 他们可用于非线性连接

FIFO在一在客户端和服务端进程之间传输数据, 如果有一个服务端进程, 它与和多客户端进程有关, 每个客户端都可以将其请求写到一个该服务端进程创建的众所周知的(各端都是到该FIFO的路径)FIFO中

IPC结构: 消息队列, 信号量, 共享存储器

每个内核中的IPC结构都用一个非负整数的标识符加以引用, 向一个消息队列发送消息或从一个消息对写取消息, 只需要知道其队列标识符, 与文件描述符不同, IPC标识符不是小的整数, 当一个IPC结构被创建, 然后又被删除时, 与这种相关联的标识符连续加1, 直到达到一个整数的最大值, 然后又转到0

无连接: 无需要先调用某种形式的打开函数就能发送消息的能力

控制流: 如果系统资源(缓冲区)短缺, 或者如果接收进程不能再接收更多消息, 则发送进程就要休眠, 当流控制条件消失时, 发送进程应自动唤醒

消息队列: 消息的链接表, 存储在内核中, 由消息队列标识符(ID)标识

信号量: 是一个计数器, 用于为多个进程提供对共享数据对象的访问

获得共享数据, 要进程的操作:
- 测试控制资源的信号量;
- 若此信号量的值为正, 则进程可以使用该资源, 然后进程会将信号量值减1, 表示它使用了一个资源单位
- 否则, 若此信号量为0, 则进程进入休眠状态, 直到信号两大于0, 进程被唤醒后, 重复整个过程
当进程不再使用由一个信号量控制的共享资源时, 该信号量曾1, 如果有进程正在休眠等待此信号量, 则唤醒他们
为了正确地实现信号量, 信号量值的测试及减1操作应当是原子操作, 为此, 信号量通常是在内核中实现的

常用的信号量形式被称为二原信号量, 它控制单个资源, 起初是值为1, 但, 信号量的初始值可以是任意一个正值, 该值表明有多少个共享资源单位可供共享应用

共享存储: 允许两个或多个进程共享一个给定的存储区, 因为数据不需要在客户端进程和服务端进程之间复制, 所以这是最快的一种IPC.使用共享存储时要掌握的唯一窍门是, 在多个进程之间同步访问一个给定的存储区.若服务器进程正在将数据放入共享存储区, 则在它作完这一操作之前, 客户端进程不应当去取这些数据, 通常, 信号量同于同步共享存储访问

高地址: [命令行参数, 环境变量] -> 栈 -> 共享存储 -> 堆 -> 未初始化的数据(由exec初始化为0) -> 初始化的数据 -> 低地址: 正文(由exec从程序文件中读入)

共享存储可由两个不相干的进程使用


套接字接口的设计目的: 同样的接口既可以用于计算机间通信, 也可以用于计算机内通信, 尽管套接字接口可以采用许多不同的网络协议进行通信, 

因特网事实上的通信标准: TCP/IP协议栈

socket是通信端点的抽象.正如使用文件描述符访问文件, 应用程序用socket描述符访问socket, 套接字描述符在UNIX系统中被当作是一种文件描述符, 事实上, 许多处理文件的描述符的函数也可以用于处理套接字描述符

虽然套接字描述符本质上是一个文件描述符, 但不是所有参数为文件描述符的函数都可以接受套接字描述符

地址族: address family

对于数据报接口, 两个对等进程之间通信时不需要逻辑连接, 只需要向对等进程所使用的套接字发送一个报文, 因此数据报提供了一个无连接的服务
字节流要求在交换数据之前, 在本地套接字和通信的对等进程的套接字之间建立一个逻辑连接

数据报是自包含报文, 发送数据报近似于个给某人邮寄信件, 你能邮寄很多信件, 但你不能保证传递的次序, 且可能有些信件丢失在路上, 每逢信件包含接收者地址, 使这封信件独立于其他所有信件, 每封信件可能送达不同的接收者

使用面向连接的协议通信就像与对方打电话, 首先, 需要通过电话建立一个连接, 连接建立好之后, 彼此能双向地通信.每个连接是端到端的通信链路.对话中不包含地址信息, 就向呼叫两端存在一个点对点虚拟连接, 且连接本身暗示特定的源和目的地


进程标识: 
- 计算机的网络地址, 它可以帮助标识网络上我们想与之通信的计算机;
- 计算机上用端口号表述的服务, 它可以帮助标识特定的进程

字节序: 与同一台计算机的进程通信时, 一般不用考虑字节序, 字节序是一个处理器架构特性, 用于指示像整数这样的大数据类型内部的字节如何排序

如果处理器架构支持大端(big-endian)字节序, 那么最大字节地址出现在最低有效字节(LSB, Least Significant Byte)上.
小端(little-endian)则相反:最低有效字节包含最小字节地址. 
不管字节如果排序, 最高有效字节(MSB, Most Signifcant Byte)总是在左边, 最低有效细节总是在右边
因此是大端还是小端, 要看最低有效字节上(即, 末尾)包含的是最大字节地址还是最小字节地址, 

  ---------------------
		   大端
  ---------------------
  n | n+1 | n+2 | n+3 |
  ---------------------
MSB					  LSB

  ---------------------
		   小端
  ---------------------
  n+3 | n+2 | n+1 | n |
  ---------------------
MSB					  LSB

网络协议指定了字节序, 因此异构计算机系统能够交换协议信息而不会被字节序锁混淆.
TCP/IP协议栈使用大端字节序.应用程序交换格式化数据时, 字节序问题就会出现, 对于TCP/IP, 地址用网络细节序来表述, 所以应用程序有时需要在处理器的字节序与网络字节序之间转换他们

将套接字与地址关联:
- 在进程正在运行的计算机上, 指定的地址必须有效;不能指定一个其他机器的地址
- 地址必须和创建套接字时的地址族所支持的格式相匹配
- 地址中的端口必须小于1024, 除非进程具有root权限
- 一般只能将一个套接字绑定到一个给定的地址上, 尽管有些协议允许多重绑定

如果要处理一个面向连接的网络服务, 那么在开始交换数据之前, 需要在请求服务的客户端进程套接字和提供服务的服务端进程套接字之间建立连接

当尝试连接服务器时, 出于一些原因, 连接可能失败, 要想一个连接请求成功, 要连接的计算机必须是开着的, 且运行着的, 服务器必须绑定到一个想与之连接的地址上, 且服务器的等待连接队列要有足够的空间

对于无连接的套接字, 数据包到达时可能已经没有次序, 如果不能将所有的数据放在一个数据包里, 则在应用程序中就必须关心数据包的次序.数据包的最大尺寸是通信协议的特征.此外, 对于无连接的套接字, 数据包可能会丢失.如果应用程序不能容忍这种丢失, 必须使用面向连接的套接字
容忍数据包丢失意味着两种选择: 
- 如果想和对等方可靠通信, 就必须对数据包编号, 且在发现数据包丢失时, 请求对等应用重传, 还必须标识重复数据包并丢弃他们, 因为数据包可能会延迟或疑似丢失, 可能请求重传之后, 他们又出现了
- 通过让用户再次尝试那个命令来处理错误, 对于简单的应用程序, 这可能就足够了, 但对于复杂的应用程序, 这种选择通常行不通, 因此, 一般在这种情况下使用面向连接的套接字比较好

面向连接的套接字的缺点在于需要更多的时间和工作来建立一个连接, 且每个连接都需要消耗较多的操作系统资源

对于面向连接的协议, 需要在交换数据之前连接到服务器, 对于服务器来说, 到来的连接请求已经足够判断出所需提供给客户端的服务, 但是对于基于数据包的协议, 需要有一种方法通知服务器来执行服务

套接字选项:
- 通用选项, 工作在所有套接字类型上
- 在套接字层管理的选项, 但是依赖于下层协议的支持
- 特定与某协议的选项, 每个协议独有的

带外数据(out-of-band data): 是一些通信协议所支持的可选功能, 与普通数据相比, 它允许更高优先级的数据传输, 带外数据先行传输, 即使传输队列已经有数据, TCP支持带外数据, 但UDP不支持.套接字接口对带外数据的支持很大程度上受TCP带外数据具体实现的影响

TCP将带外数据称为紧急数据(urgent data), TCP仅支持一个字节的紧急数据, 但允许紧急数据在普通数据传递机制数据流之外传输

TCP支持紧急标记的概念, 即在普通数据流中紧急数据流锁在的位置

UNIX套接字用于在用一台计算机上运行的进程之间的通信.虽然因特网套接字也可用于同一目的, 但是前者效率更高.UNIX套接字仅仅复制数据, 他们并不执行协议处理, 不需要添加或删除网络报头, 无需计算校验和, 无需产生序列号, 无需发送确认报文

UNIX套接字提供流和套接字两种接口.UNIX域数据报服务是可靠的, 即不会丢失报文也不会传递出错.UNIX域套接字就像是套接字和管道的混合.可以使用他们面向网络的域套接字接口或使用函数来创建一对无命名的, 相互连接的UNIX域套接字

一对相互连接的UNIX域套接字可以起到全双工管道的作用:两端对读和写开放

UNIX域套接字应用于底层通信机制

传送文件描述符: 在两个进程之间传送打开文件描述符的技术是非常有用的, 因此可以对客户端进程-服务端进程应用进行不同的设计.它使一个进程(通常是服务端进程)能够处理打开一个文件所要做的一切操作(包括将网络名翻译为网络地址, 拨号调制解调器, 协商文件锁等)以及向调用进程送回一个描述符, 该描述符可被用于以后的所有I/O函数.涉及打开文件或设备的所有细节对客户端进程而言都是透明的

当一个进程向另一个进程传送一个打开文件描述符时, 我们想让发送进程和接收进程共享同一个文件表项

从技术上, 我们是将指向一个打开文件表项的指针从一个进程发送到另一个进程, 该指针被分配存放在接收进程的第一个可用描述符项中(发送进程和接收进程中的描述符编号是不同的), 两个进程共享同一个打开文件表, 这与fork之后的父进程和子进程共享打开文件表的情况完全相同

当发送进程将描述符传送给接收进程后, 通常会关闭该描述符, 发送进程关闭该描述符并不会真的关闭该文件或设备, 其原因是该描述符仍被视为由接收进程打开, 即使接收进程尚未接收到该描述符

终端I/O有两种不同的工作模式:
- 规范模式输入处理.对终端输入, 以行为单位进行处理.对于每个读请求, 终端驱动程序最多返回一行
- 非规范模式输入处理, 输入字符不装配成行

如果不做特殊处理, 则默认模式是规范模式

终端设备是由通常位于内核中的终端驱动程序控制的, 每个终端设备都有一个输入队列和一个输出队列

终端行规程(terminal line descipline): 大多数UNIX系统在该模块中进程全部的规范处理, 可以将该模块设想成一个盒子, 位于内核通用读, 写函数和实际设备驱动程序之间

由于将规范处理分离为单独的模块, 所有的终端驱动程序都能够一致地支持规范处理

波特率(baud rate): 位/秒(bit per second), 虽然大多数终端设备对输入和输出使用同一波特率, 但是只要硬件许可, 可以将他们改为两个不同的值

软链接可以认为是类型别名

规范模式: 发送一个请求, 当一行已经输入后, 终端驱动程序即返回

- 所请求的字节数已读到时, 读返回, 无需读一个完整行, 如果读了部分行, 也不会丢失任何信息, 下一次读从前一次读的停止处开始
- 读到一个行定界符, 读返回
- 捕捉到信号, 该函数不再自动重启, 读返回

规范模式系统每次至多返回一行

非规范模式下读数据: 已经读了指定量的数据后, 或者已经超过给定量的时间后, 即通知系统返回

伪终端: 对于一个应用程序而言, 它看上去像一个终端, 但事实上它并不是一个真正的终端

终端登陆是经由自动提供语义的终端设备进行的, 在终端和运行程序之间由一个终端行规程, 同通过该规程我们能够设置终端的特殊字符(退格, 终端), 但是, 当一个登陆请求到达网络连接时, 终端行规程并不是自动被加载到网络连接和登陆shell之间的.
伪终端设备驱动程序, 用于提供终端语义, 伪终端除了用于网络登陆, 还有其它用途

通常, 一个进程打开伪终端主设备, 然后调用fork, 子进程调用一个新的会话, 打开一个相应的伪终端从设备, 将文件描述符复制到标准输入, 标准输出, 和标准错误, 然后调用exec.伪终端从设备成为子进程的控制终端

对于伪终端从设备上的用户进程来说, 其标准输入, 标准输出, 和标准错误都是终端设备.通过这些描述符, 用户进程能够处理所有终端I/O函数, 但是因为伪终端从设备不是真正的终端设备, 所以无意义的函数调用(如, 改变波特率, 发送中断符, 设置奇偶校验)将被忽略

任何写到伪终端设备的都会作为从设备的输入, 反之亦然.所有从设备端的输入都来自于伪终端中设备上的用户进程, 看起来就像是双向管道, 但从设备上的终端行规程使我们拥有普通管道没有的其他处理能力

伪终端可用于构建提供网络登陆的服务器, 如telnetd, sshd服务器, 一旦登陆shell运行在远程主机上, 就会使用类似安排

窗口系统通常提供一个终端模拟器, 这样我们就能在熟悉的命令行环境中通过shell来运行程序.终端模拟器作为shell和窗口管理器之间的媒介, 每个shell在自己的窗口中执行

shell将自己的标准输入, 标准输出, 标准错误连接到tty的从设备端.终端模拟器程序打开tty的主设备.终端模拟器除了作为窗口子系统的接口, 还要负责模拟一种特殊的终端, 这就意味着它需要根据它所模拟的设备类型来响应返回码

并发控制, 如记录锁机制

商用数据库, 常常实现自己的锁原语, 以避免获得一把无竞争的锁而需的系统调用开销, 该系统通常使用B+树, 或某种动态散列技术, 如线性散列或可扩展的散列来实现数据库

当打开一个数据库时, 通过返回值得到一个代表数据库的句柄(一个不透明指针), 将用此句柄作为参数来调用其他数据库函数

访问数据库函数通常使用两个文件存储信息: 一个索引文件和一个数据文件, 索引文件包括实际的索引值(key)和一个指向数据文件中对应数据记录的指针.由许多技术可用来组织索引文件以提高按键查询的速度和效率, 散列表和B+树是两种常用的技术


多个进程访问同一数据库:
- 集中式: 由一个进程作为数据库管理者, 所有的数据库访问工作由此进程完成, 其他进程通过IPC机制与此中心进程进行联系
- 非集中式: 每个库函数使用要求的并发控制(加锁), 然后发起自己的I/O函数调用
如果由适当的加锁例程, 因为避免了使用IPC, 那么非集中式方法一般要快些

集中式的优点:
- 能够根据需要来对操作模式进程调整, 如, 可以通过中心进程给不同的进程赋予不同的优先级, 这会影响中心进程对I/O操作的调度;而非集中式方法很难做到这一点, 在这种情况下, 只能依赖于操作系统内核的磁盘I/O调度策略和加锁策略, 如, 当3个进程同时等待一个即将可用的锁时, 我们无法确定那个进程将得到这个锁
- 恢复要比非集中式方法容易.集中式方法中, 所有状态信息都集中存放在一处, 如, 杀死了数据库进程, 只需在该处查看以识别出需要解决的未完成事物, 然后将数据库恢复到一致状态

粗粒度锁: 最简单的加锁方式是将两个文件中的一个作为整个数据库的锁, 并要求调用着在对数据库进程呢个操作前必须获得这把锁; 但它限制了并发, 用该锁时, 当一个进程向一条散列链中添加一条记录时, 其他进程无法访问另一条散列链上的记录

细粒度锁: 改进了粗粒度锁, 提供了更高的并发行, 一个读进程或写进程在操作一条记录前必须先获得此纪录所在散列链的读锁或写锁, 一条散列链允许同时由多个读进程, 但时能有一个写进程, 一个写进程在访问空闲区链表前, 必须获得空闲区链表的写锁, 当向索引文件或数据库文件末尾追加一条新纪录时, 必须获得对应文件相应区域的写锁



